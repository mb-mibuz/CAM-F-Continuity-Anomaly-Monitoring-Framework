import React, { useState, useEffect } from 'react';
import ModalBase from './ModalBase';
import NewAngleModal from './NewAngleModal';
import ReferenceCaptureModal from './ReferenceCaptureModal';
import { validateName, sanitizeName } from '../../utils/nameValidator';
import { useScene, useCreateAngle } from '../../queries/hooks';
import { useAppStore } from '../../stores';

export default function NewTakeModal({ angles: initialAngles, onClose, onCreate, onCreateAngle, sceneId }) {
  const [step, setStep] = useState(1); // 1 = name/angle, 2 = capture reference
  const [takeName, setTakeName] = useState('');
  const [selectedAngleId, setSelectedAngleId] = useState('');
  const [nameError, setNameError] = useState('');
  const [angleError, setAngleError] = useState('');
  const [showNewAngleModal, setShowNewAngleModal] = useState(false);
  const [angles, setAngles] = useState(initialAngles);
  const [manuallyEdited, setManuallyEdited] = useState(false);
  const [selectedAngle, setSelectedAngle] = useState(null);
  
  // Use React Query for scene data
  const { data: sceneData } = useScene(sceneId);
  const createAngleMutation = useCreateAngle();
  
  // Helper function to generate take name for an angle
  const generateTakeName = (angle) => {
    if (angle && angle.takes) {
      const takeCount = angle.takes.length;
      return `Take #${takeCount + 1}`;
    }
    return 'Take #1';
  };

  // Set default angle and take name when modal opens
  useEffect(() => {
    // Sort angles by creation date (most recent first)
    const sortedAngles = [...initialAngles].sort((a, b) => {
      const dateA = a.created_at ? new Date(a.created_at) : new Date(0);
      const dateB = b.created_at ? new Date(b.created_at) : new Date(0);
      return dateB - dateA;
    });
    
    setAngles(sortedAngles);
    
    // Select the most recent angle by default
    if (sortedAngles.length > 0) {
      const latestAngle = sortedAngles[0];
      setSelectedAngleId(latestAngle.id.toString());
      setSelectedAngle(latestAngle);
      
      // Set the take name for this angle
      const newTakeName = generateTakeName(latestAngle);
      setTakeName(newTakeName);
      setManuallyEdited(false);
    }
  }, [initialAngles]);

  // Update take name when selected angle changes
  useEffect(() => {
    if (selectedAngleId && !manuallyEdited) {
      const angle = angles.find(a => a.id.toString() === selectedAngleId);
      if (angle) {
        setSelectedAngle(angle);
        const newTakeName = generateTakeName(angle);
        setTakeName(newTakeName);
      }
    }
  }, [selectedAngleId, angles, manuallyEdited]);

  const handleNameChange = (e) => {
    const value = e.target.value;
    setTakeName(value);
    
    // Mark as manually edited if the user changes the name
    const angle = angles.find(a => a.id.toString() === selectedAngleId);
    if (angle) {
      const autoGeneratedName = generateTakeName(angle);
      setManuallyEdited(value !== autoGeneratedName);
    }
    
    if (nameError) {
      setNameError('');
    }
  };

  const handleAngleChange = (e) => {
    const value = e.target.value;
    
    if (value === 'new') {
      setShowNewAngleModal(true);
    } else {
      setSelectedAngleId(value);
      if (angleError) {
        setAngleError('');
      }
      
      // Reset manual edit flag when angle changes
      setManuallyEdited(false);
    }
  };

  const handleNextOrCreate = () => {
    // Validate name
    const sanitized = sanitizeName(takeName);
    const validation = validateName(sanitized);
    
    if (!validation.isValid) {
      setNameError(validation.error);
      return;
    }
    
    // Validate angle selection
    if (!selectedAngleId) {
      setAngleError('Please select an angle');
      return;
    }
    
    // Check if this angle has any takes
    const angle = angles.find(a => a.id.toString() === selectedAngleId);
    if (angle && (!angle.takes || angle.takes.length === 0)) {
      // This is the first take for this angle, go to capture step
      setStep(2);
    } else {
      // Angle already has takes, create immediately
      onCreate(sanitized, parseInt(selectedAngleId));
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !showNewAngleModal && step === 1) {
      handleNextOrCreate();
    }
  };

  const handleCreateAngle = async (angleName) => {
    try {
      const newAngle = await createAngleMutation.mutateAsync({
        sceneId: parseInt(sceneId, 10),  // Changed from scene_id to sceneId
        name: angleName
      });
      
      // Add the new angle with empty takes array
      const angleWithTakes = { ...newAngle, takes: [] };
      
      // Update local angles list (add to beginning for most recent first)
      const updatedAngles = [angleWithTakes, ...angles];
      setAngles(updatedAngles);
      
      // Select the new angle
      const angleIdStr = newAngle.id.toString();
      setSelectedAngleId(angleIdStr);
      setSelectedAngle(angleWithTakes);
      
      // Reset manual edit flag so the take name updates automatically
      setManuallyEdited(false);
      
      // Force update the take name immediately
      const newTakeName = generateTakeName(angleWithTakes);
      setTakeName(newTakeName);
      
      // Clear any errors
      setAngleError('');
      setNameError('');
      
      setShowNewAngleModal(false);
      
      // Don't call parent's onCreateAngle - we already created the angle here
    } catch (error) {
      console.error('Failed to create angle:', error);
      const appStore = useAppStore.getState();
      appStore.addNotification({
        type: 'error',
        message: 'Failed to create angle: ' + error.message
      });
    }
  };

  const handleBackFromCapture = () => {
    setStep(1);
  };

  const handleCreateFromCapture = async (name, angleId, takeId) => {
    // Pass the takeId up to the parent
    onClose();
    // The parent will handle navigation
    if (onCreate) {
      // Modified to pass takeId
      onCreate(name, angleId, takeId);
    }
  };

  if (step === 2 && selectedAngle && sceneData) {
    return (
      <ReferenceCaptureModal
        takeName={takeName}
        angleId={parseInt(selectedAngleId)}
        angleName={selectedAngle.name}
        sceneId={sceneId}
        frameRate={sceneData.frame_rate}
        onBack={handleBackFromCapture}
        onCreate={handleCreateFromCapture}
        onClose={onClose}
      />
    );
  }

  return (
    <>
      <ModalBase onClose={onClose}>
        <div className="p-8">
          <h2 className="text-18 font-semibold mb-6">New Take</h2>
          
          <div className="mb-4">
            <label className="block text-14 font-medium mb-2">Take Name</label>
            <input 
              type="text"
              value={takeName}
              onChange={handleNameChange}
              onKeyPress={handleKeyPress}
              className={`w-full px-3 py-2 border rounded focus:outline-none ${
                nameError ? 'border-red-500 focus:border-red-500' : 'border-gray-300 focus:border-black'
              }`}
              autoFocus
            />
            {nameError && (
              <p className="mt-1 text-12 text-red-600">{nameError}</p>
            )}
          </div>
          
          <div className="mb-6">
            <label className="block text-14 font-medium mb-2">Angle</label>
            <select
              value={selectedAngleId}
              onChange={handleAngleChange}
              className={`w-full px-3 py-2 border rounded focus:outline-none ${
                angleError ? 'border-red-500 focus:border-red-500' : 'border-gray-300 focus:border-black'
              }`}
            >
              <option value="">Select angle...</option>
              <option value="new">+ New Angle</option>
              {angles.map(angle => (
                <option key={angle.id} value={angle.id}>
                  {angle.name} ({angle.takes ? angle.takes.length : 0} takes)
                </option>
              ))}
            </select>
            {angleError && (
              <p className="mt-1 text-12 text-red-600">{angleError}</p>
            )}
          </div>
          
          <div className="flex justify-end gap-3">
            <button 
              onClick={onClose}
              className="px-4 py-2 text-14 font-medium bg-white border border-gray-300 rounded hover:bg-gray-50"
            >
              Cancel
            </button>
            <button 
              onClick={handleNextOrCreate}
              disabled={!takeName.trim() || !selectedAngleId || nameError || createAngleMutation.isLoading}
              className={`px-4 py-2 text-14 font-medium text-white rounded ${
                takeName.trim() && selectedAngleId && !nameError && !createAngleMutation.isLoading
                  ? 'bg-primary hover:opacity-80' 
                  : 'bg-gray-300 cursor-not-allowed'
              }`}
            >
              {createAngleMutation.isLoading ? 'Creating...' : 
               (selectedAngle && (!selectedAngle.takes || selectedAngle.takes.length === 0) ? 'Next' : 'Create')}
            </button>
          </div>
        </div>
      </ModalBase>

      {showNewAngleModal && (
        <NewAngleModal
          onClose={() => setShowNewAngleModal(false)}
          onCreate={handleCreateAngle}
        />
      )}
    </>
  );
}